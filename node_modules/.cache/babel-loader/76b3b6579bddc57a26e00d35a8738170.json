{"ast":null,"code":"import _slicedToArray from \"/workspace/uniswap-info/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { useEffect, useState } from 'react';\nimport dayjs from 'dayjs';\nimport utc from 'dayjs/plugin/utc';\nimport { client } from '../apollo/client';\nimport { CHART_QUERY, TICKER_QUERY } from '../apollo/queries';\nexport function useChart(exchangeAddress, daysToQuery) {\n  dayjs.extend(utc);\n\n  const _useState = useState([]),\n        _useState2 = _slicedToArray(_useState, 2),\n        chartData = _useState2[0],\n        setChartData = _useState2[1];\n\n  useEffect(() => {\n    const fetchChartData = async function (exchangeAddress, daysToQuery) {\n      try {\n        const utcEndTime = dayjs.utc();\n        let utcStartTime;\n\n        switch (daysToQuery) {\n          case 'all':\n            utcStartTime = utcEndTime.subtract(1, 'year').startOf('year');\n            break;\n\n          case '3months':\n            utcStartTime = utcEndTime.subtract(3, 'month');\n            break;\n\n          case '1month':\n            utcStartTime = utcEndTime.subtract(1, 'month');\n            break;\n\n          case '1week':\n          default:\n            utcStartTime = utcEndTime.subtract(7, 'day').startOf('day');\n            break;\n        }\n\n        let startTime = utcStartTime.unix() - 1; // -1 because we filter on greater than in the query\n\n        let data = [];\n        let dataEnd = false;\n\n        while (!dataEnd) {\n          let result = await client.query({\n            query: CHART_QUERY,\n            variables: {\n              exchangeAddr: exchangeAddress,\n              date: startTime\n            },\n            fetchPolicy: 'cache-first'\n          });\n          data = data.concat(result.data.exchangeDayDatas);\n\n          if (result.data.exchangeDayDatas.length !== 100) {\n            dataEnd = true;\n          } else {\n            startTime = result.data.exchangeDayDatas[result.data.exchangeDayDatas.length - 1].date;\n          }\n        } // if no txs in the current timestamp ut must be most current\n\n\n        if (!data[0]) {\n          const result = await client.query({\n            query: TICKER_QUERY,\n            variables: {\n              id: exchangeAddress\n            },\n            fetchPolicy: 'network-only'\n          });\n\n          if (result) {\n            data[0] = result.data.exchange;\n            data[0].date = startTime;\n            data[0].marginalEthRate = data[0].price;\n            data[0].tokenPriceUSD = data[0].priceUSD;\n          }\n        } // use to keep track of which days had volume\n\n\n        let dayIndexSet = new Set();\n        let dayIndexArray = [];\n        const oneDay = 24 * 60 * 60;\n        data.forEach((dayData, i) => {\n          // add the day index to the set of days\n          dayIndexSet.add((data[i].date / oneDay).toFixed(0));\n          dayIndexArray.push(data[i]);\n          data[i].dayString = data[i].date;\n          let ethVolume = data[i].ethVolume;\n          let ethPriceUsd = parseFloat(data[i].marginalEthRate) * parseFloat(data[i].tokenPriceUSD);\n          data[i].ethVolume = parseFloat(ethVolume);\n          data[i].tokenPriceUSD = parseFloat(data[i].tokenPriceUSD);\n          data[i].tokensPerUSD = 1 / parseFloat(data[i].tokenPriceUSD);\n          data[i].usdVolume = parseFloat(ethVolume) * ethPriceUsd;\n          data[i].ethPerToken = 1 / parseFloat(data[i].marginalEthRate);\n          data[i].tokensPerEth = parseFloat(data[i].marginalEthRate);\n          let y = data[i].ethBalance;\n          data[i].ethBalance = parseFloat(y);\n          data[i].tokenBalance = parseFloat(data[i].tokenBalance);\n          data[i].usdLiquidity = parseFloat(data[i].tokenBalance) * parseFloat(data[i].tokenPriceUSD) + parseFloat(data[i].ethBalance) * ethPriceUsd;\n          data[i].ethLiquidity = parseFloat(data[i].ethBalance) * 2;\n        }); // fill in empty days\n\n        let timestamp = data[0].date ? data[0].date : startTime;\n        let latestLiquidityUSD = data[0].usdLiquidity;\n        let latestLiquidityETH = data[0].ethLiquidity;\n        let latestEthBalance = data[0].ethBalance;\n        let latestTokenBalance = data[0].tokenBalance;\n        let latestEthPerToken = data[0].ethPerToken;\n        let latestTokenPriceUSD = data[0].tokenPriceUSD;\n        let latestTokensPerUSD = data[0].tokensPerUSD;\n        let latestTokensPerETH = data[0].tokensPerEth;\n        let index = 1;\n\n        while (timestamp < utcEndTime.unix() - oneDay) {\n          const nextDay = timestamp + oneDay;\n          let currentDayIndex = (nextDay / oneDay).toFixed(0);\n\n          if (!dayIndexSet.has(currentDayIndex)) {\n            data.push({\n              date: nextDay,\n              dayString: nextDay,\n              ethVolume: 0,\n              usdVolume: 0,\n              usdLiquidity: latestLiquidityUSD,\n              ethLiquidity: latestLiquidityETH,\n              ethBalance: latestEthBalance,\n              tokenBalance: latestTokenBalance,\n              tokenPriceUSD: latestTokenPriceUSD,\n              ethPerToken: latestEthPerToken,\n              tokensPerUSD: latestTokensPerUSD,\n              tokensPerEth: latestTokensPerETH\n            });\n          } else {\n            latestLiquidityUSD = dayIndexArray[index].usdLiquidity;\n            latestLiquidityETH = dayIndexArray[index].ethLiquidity;\n            latestEthBalance = dayIndexArray[index].ethBalance;\n            latestTokenBalance = dayIndexArray[index].tokenBalance;\n            latestEthPerToken = dayIndexArray[index].ethPerToken;\n            latestTokenPriceUSD = dayIndexArray[index].tokenPriceUSD;\n            latestTokensPerUSD = dayIndexArray[index].tokensPerUSD;\n            latestTokensPerETH = dayIndexArray[index].tokensPerEth;\n            index = index + 1;\n          }\n\n          timestamp = nextDay;\n        }\n\n        data = data.sort((a, b) => parseInt(a.date) > parseInt(b.date) ? 1 : -1);\n        setChartData(data);\n      } catch (err) {\n        console.log('error: ', err);\n      }\n    };\n\n    fetchChartData(exchangeAddress, daysToQuery);\n  }, [exchangeAddress, daysToQuery]);\n  return chartData;\n}","map":{"version":3,"sources":["/workspace/uniswap-info/src/Data/ChartData.js"],"names":["useEffect","useState","dayjs","utc","client","CHART_QUERY","TICKER_QUERY","useChart","exchangeAddress","daysToQuery","extend","chartData","setChartData","fetchChartData","utcEndTime","utcStartTime","subtract","startOf","startTime","unix","data","dataEnd","result","query","variables","exchangeAddr","date","fetchPolicy","concat","exchangeDayDatas","length","id","exchange","marginalEthRate","price","tokenPriceUSD","priceUSD","dayIndexSet","Set","dayIndexArray","oneDay","forEach","dayData","i","add","toFixed","push","dayString","ethVolume","ethPriceUsd","parseFloat","tokensPerUSD","usdVolume","ethPerToken","tokensPerEth","y","ethBalance","tokenBalance","usdLiquidity","ethLiquidity","timestamp","latestLiquidityUSD","latestLiquidityETH","latestEthBalance","latestTokenBalance","latestEthPerToken","latestTokenPriceUSD","latestTokensPerUSD","latestTokensPerETH","index","nextDay","currentDayIndex","has","sort","a","b","parseInt","err","console","log"],"mappings":"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","sourcesContent":["import { useEffect, useState } from 'react'\nimport dayjs from 'dayjs'\nimport utc from 'dayjs/plugin/utc'\n\nimport { client } from '../apollo/client'\nimport { CHART_QUERY, TICKER_QUERY } from '../apollo/queries'\n\nexport function useChart(exchangeAddress, daysToQuery) {\n  dayjs.extend(utc)\n\n  const [chartData, setChartData] = useState([])\n\n  useEffect(() => {\n    const fetchChartData = async function(exchangeAddress, daysToQuery) {\n      try {\n        const utcEndTime = dayjs.utc()\n        let utcStartTime\n        switch (daysToQuery) {\n          case 'all':\n            utcStartTime = utcEndTime.subtract(1, 'year').startOf('year')\n            break\n          case '3months':\n            utcStartTime = utcEndTime.subtract(3, 'month')\n            break\n          case '1month':\n            utcStartTime = utcEndTime.subtract(1, 'month')\n            break\n          case '1week':\n          default:\n            utcStartTime = utcEndTime.subtract(7, 'day').startOf('day')\n            break\n        }\n        let startTime = utcStartTime.unix() - 1 // -1 because we filter on greater than in the query\n        let data = []\n        let dataEnd = false\n        while (!dataEnd) {\n          let result = await client.query({\n            query: CHART_QUERY,\n            variables: {\n              exchangeAddr: exchangeAddress,\n              date: startTime\n            },\n            fetchPolicy: 'cache-first'\n          })\n          data = data.concat(result.data.exchangeDayDatas)\n          if (result.data.exchangeDayDatas.length !== 100) {\n            dataEnd = true\n          } else {\n            startTime = result.data.exchangeDayDatas[result.data.exchangeDayDatas.length - 1].date\n          }\n        }\n\n        // if no txs in the current timestamp ut must be most current\n        if (!data[0]) {\n          const result = await client.query({\n            query: TICKER_QUERY,\n            variables: {\n              id: exchangeAddress\n            },\n            fetchPolicy: 'network-only'\n          })\n          if (result) {\n            data[0] = result.data.exchange\n            data[0].date = startTime\n            data[0].marginalEthRate = data[0].price\n            data[0].tokenPriceUSD = data[0].priceUSD\n          }\n        }\n        // use to keep track of which days had volume\n        let dayIndexSet = new Set()\n        let dayIndexArray = []\n        const oneDay = 24 * 60 * 60\n        data.forEach((dayData, i) => {\n          // add the day index to the set of days\n          dayIndexSet.add((data[i].date / oneDay).toFixed(0))\n          dayIndexArray.push(data[i])\n          data[i].dayString = data[i].date\n          let ethVolume = data[i].ethVolume\n          let ethPriceUsd = parseFloat(data[i].marginalEthRate) * parseFloat(data[i].tokenPriceUSD)\n          data[i].ethVolume = parseFloat(ethVolume)\n          data[i].tokenPriceUSD = parseFloat(data[i].tokenPriceUSD)\n          data[i].tokensPerUSD = 1 / parseFloat(data[i].tokenPriceUSD)\n          data[i].usdVolume = parseFloat(ethVolume) * ethPriceUsd\n          data[i].ethPerToken = 1 / parseFloat(data[i].marginalEthRate)\n          data[i].tokensPerEth = parseFloat(data[i].marginalEthRate)\n          let y = data[i].ethBalance\n          data[i].ethBalance = parseFloat(y)\n          data[i].tokenBalance = parseFloat(data[i].tokenBalance)\n          data[i].usdLiquidity =\n            parseFloat(data[i].tokenBalance) * parseFloat(data[i].tokenPriceUSD) +\n            parseFloat(data[i].ethBalance) * ethPriceUsd\n          data[i].ethLiquidity = parseFloat(data[i].ethBalance) * 2\n        })\n        // fill in empty days\n        let timestamp = data[0].date ? data[0].date : startTime\n        let latestLiquidityUSD = data[0].usdLiquidity\n        let latestLiquidityETH = data[0].ethLiquidity\n        let latestEthBalance = data[0].ethBalance\n        let latestTokenBalance = data[0].tokenBalance\n        let latestEthPerToken = data[0].ethPerToken\n        let latestTokenPriceUSD = data[0].tokenPriceUSD\n        let latestTokensPerUSD = data[0].tokensPerUSD\n        let latestTokensPerETH = data[0].tokensPerEth\n        let index = 1\n        while (timestamp < utcEndTime.unix() - oneDay) {\n          const nextDay = timestamp + oneDay\n          let currentDayIndex = (nextDay / oneDay).toFixed(0)\n          if (!dayIndexSet.has(currentDayIndex)) {\n            data.push({\n              date: nextDay,\n              dayString: nextDay,\n              ethVolume: 0,\n              usdVolume: 0,\n              usdLiquidity: latestLiquidityUSD,\n              ethLiquidity: latestLiquidityETH,\n              ethBalance: latestEthBalance,\n              tokenBalance: latestTokenBalance,\n              tokenPriceUSD: latestTokenPriceUSD,\n              ethPerToken: latestEthPerToken,\n              tokensPerUSD: latestTokensPerUSD,\n              tokensPerEth: latestTokensPerETH\n            })\n          } else {\n            latestLiquidityUSD = dayIndexArray[index].usdLiquidity\n            latestLiquidityETH = dayIndexArray[index].ethLiquidity\n            latestEthBalance = dayIndexArray[index].ethBalance\n            latestTokenBalance = dayIndexArray[index].tokenBalance\n            latestEthPerToken = dayIndexArray[index].ethPerToken\n            latestTokenPriceUSD = dayIndexArray[index].tokenPriceUSD\n            latestTokensPerUSD = dayIndexArray[index].tokensPerUSD\n            latestTokensPerETH = dayIndexArray[index].tokensPerEth\n            index = index + 1\n          }\n          timestamp = nextDay\n        }\n        data = data.sort((a, b) => (parseInt(a.date) > parseInt(b.date) ? 1 : -1))\n        setChartData(data)\n      } catch (err) {\n        console.log('error: ', err)\n      }\n    }\n    fetchChartData(exchangeAddress, daysToQuery)\n  }, [exchangeAddress, daysToQuery])\n\n  return chartData\n}\n"]},"metadata":{},"sourceType":"module"}